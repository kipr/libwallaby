.TH "kipr::create::Create" 3 "Mon Sep 12 2022" "Version 1.0.0" "libkipr" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kipr::create::Create \- Facilitates communication with the iRobot (R) \fBCreate\fP (TM)  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <create\&.hpp>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBMode\fP { \fBOffMode\fP, \fBPassiveMode\fP, \fBSafeMode\fP, \fBFullMode\fP }"
.br
.ti -1c
.RI "enum \fBBaudRate\fP { \fBBaud57600\fP = 0, \fBBaud115200\fP = 1 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~Create\fP ()"
.br
.ti -1c
.RI "bool \fBconnect\fP ()"
.br
.ti -1c
.RI "bool \fBconnect\fP (const \fBBaudRate\fP baudRate)"
.br
.ti -1c
.RI "bool \fBdisconnect\fP ()"
.br
.ti -1c
.RI "bool \fBisConnected\fP () const"
.br
.ti -1c
.RI "void \fBsetOffMode\fP ()"
.br
.ti -1c
.RI "void \fBsetPassiveMode\fP ()"
.br
.ti -1c
.RI "void \fBsetSafeMode\fP ()"
.br
.ti -1c
.RI "void \fBsetFullMode\fP ()"
.br
.ti -1c
.RI "void \fBsetMode\fP (const \fBCreate::Mode\fP &\fBmode\fP)"
.br
.ti -1c
.RI "\fBCreate::Mode\fP \fBmode\fP ()"
.br
.ti -1c
.RI "void \fBsend\fP (const \fBCreateScript\fP &script)"
.br
.ti -1c
.RI "bool \fBwrite\fP (const unsigned char &c)"
.br
.ti -1c
.RI "bool \fBwrite\fP (const unsigned char *data, const size_t &len)"
.br
.ti -1c
.RI "void \fBflush\fP ()"
.br
.ti -1c
.RI "short \fBread\fP ()"
.br
.ti -1c
.RI "int \fBread\fP (unsigned char *data, const size_t &len)"
.br
.ti -1c
.RI "bool \fBblockingRead\fP (unsigned char *data, const size_t &size, unsigned timeout=25)"
.br
.ti -1c
.RI "template<typename T > bool \fBblockingRead\fP (T &data, unsigned timeout=0)"
.br
.ti -1c
.RI "void \fBsetLeds\fP (const bool &advance, const bool &play, const unsigned char &color, const unsigned char &brightness)"
.br
.ti -1c
.RI "void \fBdrive\fP (const short &velocity, const short &radius)"
.br
.ti -1c
.RI "void \fBdriveDirect\fP (const short &left, const short &right)"
.br
.ti -1c
.RI "void \fBdriveStraight\fP (const short &speed)"
.br
.ti -1c
.RI "void \fBstop\fP ()"
.br
.ti -1c
.RI "void \fBturn\fP (const short &\fBangle\fP, const unsigned short &speed)"
.br
.ti -1c
.RI "void \fBmove\fP (const short &millimeters, const unsigned short &speed)"
.br
.ti -1c
.RI "void \fBspin\fP (const short &speed)"
.br
.ti -1c
.RI "short \fBangularVelocity\fP () const"
.br
.ti -1c
.RI "void \fBspinClockwise\fP (const short &speed)"
.br
.ti -1c
.RI "void \fBspinCounterClockwise\fP (const short &speed)"
.br
.ti -1c
.RI "bool \fBsetBaudRate\fP (const unsigned char &baudCode)"
.br
.ti -1c
.RI "void \fBsetDistance\fP (const int \fBdistance\fP)"
.br
.ti -1c
.RI "void \fBsetAngle\fP (const int \fBangle\fP)"
.br
.ti -1c
.RI "\fBbutton::AbstractButton\fP * \fBplayButton\fP () const"
.br
.ti -1c
.RI "\fBbutton::AbstractButton\fP * \fBadvanceButton\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBwall\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBcliffLeft\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBcliffFrontLeft\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBcliffFrontRight\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBcliffRight\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBvirtualWall\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBwallSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBcliffLeftSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBcliffFrontLeftSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBcliffFrontRightSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBcliffRightSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBcargoBayAnalogSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned char > * \fBcargoBayDigitalInputs\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned char > * \fBir\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned char > * \fBchargingState\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< char > * \fBbatteryTemperature\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBbatteryCharge\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBbatteryCapacity\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< int > * \fBangle\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< int > * \fBdistance\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBbumpLeft\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBbumpRight\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBwheelDropLeft\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBwheelDropRight\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBwheelDropCaster\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBlightBumpLeft\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBlightBumpFrontLeft\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBlightBumpCenterLeft\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBlightBumpCenterRight\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBlightBumpFrontRight\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< bool > * \fBlightBumpRight\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBlightBumpLeftSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBlightBumpFrontLeftSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBlightBumpCenterLeftSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBlightBumpCenterRightSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBlightBumpFrontRightSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned short > * \fBlightBumpRightSignal\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned char > * \fBsongPlaying\fP () const"
.br
.ti -1c
.RI "\fBsensor::Sensor\fP< unsigned char > * \fBsongNumber\fP () const"
.br
.ti -1c
.RI "void \fBsetRefreshRate\fP (const unsigned short &\fBrefreshRate\fP)"
.br
.ti -1c
.RI "const unsigned short & \fBrefreshRate\fP () const"
.br
.ti -1c
.RI "bool \fBloadSong\fP (const unsigned char *song, const unsigned char length, const unsigned char songNum)"
.br
.ti -1c
.RI "bool \fBplaySong\fP (const unsigned char songNum)"
.br
.ti -1c
.RI "const \fBCreateState\fP * \fBstate\fP ()"
.br
.ti -1c
.RI "const \fBCreatePackets::_1\fP * \fBsensorPacket1\fP ()"
.br
.ti -1c
.RI "const \fBCreatePackets::_2\fP * \fBsensorPacket2\fP ()"
.br
.ti -1c
.RI "const \fBCreatePackets::_3\fP * \fBsensorPacket3\fP ()"
.br
.ti -1c
.RI "const \fBCreatePackets::_4\fP * \fBsensorPacket4\fP ()"
.br
.ti -1c
.RI "const \fBCreatePackets::_5\fP * \fBsensorPacket5\fP ()"
.br
.ti -1c
.RI "const \fBCreatePackets::_101\fP * \fBsensorPacket101\fP ()"
.br
.ti -1c
.RI "void \fBbeginAtomicOperation\fP ()"
.br
.ti -1c
.RI "void \fBendAtomicOperation\fP ()"
.br
.ti -1c
.RI "void \fBsetDefaultBaudRate\fP (const \fBBaudRate\fP \fBdefaultBaudRate\fP)"
.br
.ti -1c
.RI "\fBBaudRate\fP \fBdefaultBaudRate\fP () const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBCreate\fP * \fBinstance\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Facilitates communication with the iRobot (R) \fBCreate\fP (TM) 

Provides high level bindings for a significant majority of the iRobot Open Interface specification\&. 
.PP
\fBAuthor\fP
.RS 4
Braden McDorman 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBkipr::create::Create::BaudRate\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIBaud57600 \fP\fP
.TP
\fB\fIBaud115200 \fP\fP
.SS "enum \fBkipr::create::Create::Mode\fP"
The 'Mode' of the create\&.
.IP "\(bu" 2
PassiveMode: No movement allowed\&.
.IP "\(bu" 2
SafeMode: Movement is allowed, but the \fBCreate\fP will stop if it's safety sensors are activated\&.
.IP "\(bu" 2
FullMode: All movement is allowed, even if it is considered dangerous\&. This mode is recommended for Botball\&. 
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIOffMode \fP\fP
.TP
\fB\fIPassiveMode \fP\fP
.TP
\fB\fISafeMode \fP\fP
.TP
\fB\fIFullMode \fP\fP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "kipr::create::Create::~Create ()"

.SH "Member Function Documentation"
.PP 
.SS "\fBbutton::AbstractButton\fP* kipr::create::Create::advanceButton () const"

.SS "\fBsensor::Sensor\fP<int>* kipr::create::Create::angle () const"

.SS "short kipr::create::Create::angularVelocity () const"
Returns the current angular velocity of the create\&. This value is positive for counter-clockwise velocity and negative for clockwise velocity\&. 
.PP
\fBReturns\fP
.RS 4
angular velocity of the create, between 0 and 1000 mm/s 
.RE
.PP

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::batteryCapacity () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::batteryCharge () const"

.SS "\fBsensor::Sensor\fP<char>* kipr::create::Create::batteryTemperature () const"

.SS "void kipr::create::Create::beginAtomicOperation ()\fC [inline]\fP"

.SS "template<typename T > bool kipr::create::Create::blockingRead (T & data, unsigned timeout = \fC0\fP)\fC [inline]\fP"

.SS "bool kipr::create::Create::blockingRead (unsigned char * data, const size_t & size, unsigned timeout = \fC25\fP)"
Reads until the specified number of bytes have been read\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Pointer to the buffer to read into 
.br
\fIsize\fP Number of bytes to be read 
.RE
.PP
\fBReturns\fP
.RS 4
true if reading succeeded, false if there was an error 
.RE
.PP
\fB\fBThis\fP function is blocking\&.\fP
.RS 4

.RE
.PP

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::bumpLeft () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::bumpRight () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::cargoBayAnalogSignal () const"

.SS "\fBsensor::Sensor\fP<unsigned char>* kipr::create::Create::cargoBayDigitalInputs () const"

.SS "\fBsensor::Sensor\fP<unsigned char>* kipr::create::Create::chargingState () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::cliffFrontLeft () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::cliffFrontLeftSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::cliffFrontRight () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::cliffFrontRightSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::cliffLeft () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::cliffLeftSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::cliffRight () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::cliffRightSignal () const"

.SS "bool kipr::create::Create::connect ()"
Attempts to establish a connection to the create 
.PP
\fBReturns\fP
.RS 4
true if connection succeeded, false if connection failed 
.RE
.PP
\fBSee also\fP
.RS 4
\fBdisconnect\fP 
.PP
\fBisConnected\fP 
.RE
.PP

.SS "bool kipr::create::Create::connect (const \fBBaudRate\fP baudRate)"
Attempts to establish a connection to the create 
.PP
\fBParameters\fP
.RS 4
\fIbaudRate\fP The desired communication speed with the \fBCreate\fP 1 or 2 
.RE
.PP
\fBReturns\fP
.RS 4
true if connection succeeded, false if connection failed 
.RE
.PP
\fBSee also\fP
.RS 4
\fBdisconnect\fP 
.PP
\fBisConnected\fP 
.RE
.PP

.SS "\fBBaudRate\fP kipr::create::Create::defaultBaudRate () const\fC [inline]\fP"

.SS "bool kipr::create::Create::disconnect ()"
Cleans up connection to the create 
.PP
\fBReturns\fP
.RS 4
true if disconnected, false otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBconnect\fP 
.PP
\fBisConnected\fP 
.RE
.PP

.SS "\fBsensor::Sensor\fP<int>* kipr::create::Create::distance () const"

.SS "void kipr::create::Create::drive (const short & velocity, const short & radius)"

.SS "void kipr::create::Create::driveDirect (const short & left, const short & right)"

.SS "void kipr::create::Create::driveStraight (const short & speed)"

.SS "void kipr::create::Create::endAtomicOperation ()\fC [inline]\fP"

.SS "void kipr::create::Create::flush ()"

.SS "static \fBCreate\fP* kipr::create::Create::instance ()\fC [static]\fP"
The \fBCreate\fP class is a singleton, which means that you cannot instantiate it directly\&. To get an instance of the create, you must use this method\&. 
.PP
\fBReturns\fP
.RS 4
The global instance of the \fBCreate\fP class 
.RE
.PP

.SS "\fBsensor::Sensor\fP<unsigned char>* kipr::create::Create::ir () const"

.SS "bool kipr::create::Create::isConnected () const"

.PP
\fBReturns\fP
.RS 4
true if connected, false if not connected 
.RE
.PP
\fBSee also\fP
.RS 4
\fBconnect\fP 
.PP
\fBdisconnect\fP 
.RE
.PP

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::lightBumpCenterLeft () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::lightBumpCenterLeftSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::lightBumpCenterRight () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::lightBumpCenterRightSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::lightBumpFrontLeft () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::lightBumpFrontLeftSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::lightBumpFrontRight () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::lightBumpFrontRightSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::lightBumpLeft () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::lightBumpLeftSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::lightBumpRight () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::lightBumpRightSignal () const"

.SS "\fBCreate::Mode\fP kipr::create::Create::mode ()"

.SS "void kipr::create::Create::move (const short & millimeters, const unsigned short & speed)"
A very accurate move method based on time rather than the create's own readings, which are often less than accurate\&. 
.PP
\fBParameters\fP
.RS 4
\fImillimeters\fP The amount to move, in millimeters\&. 
.br
\fIspeed\fP The speed each wheel should move at, in mm/s\&. 
.RE
.PP
\fB\fBThis\fP function is blocking\&.\fP
.RS 4

.RE
.PP

.SS "\fBbutton::AbstractButton\fP* kipr::create::Create::playButton () const"

.SS "short kipr::create::Create::read ()"
Reads one byte\&. 
.PP
\fBReturns\fP
.RS 4
The read byte, or less than zero on error\&. 
.RE
.PP

.SS "int kipr::create::Create::read (unsigned char * data, const size_t & len)"
Reads a maximum of len bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Pointer to the buffer to read into\&. 
.br
\fIlen\fP Maxiumum number of bytes to read\&. Should be less than or equal to the size of data\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The number of bytes actually read, or less than zero on error\&. 
.RE
.PP

.SS "const unsigned short& kipr::create::Create::refreshRate () const"

.SS "void kipr::create::Create::send (const \fBCreateScript\fP & script)"

.SS "const \fBCreatePackets::_1\fP* kipr::create::Create::sensorPacket1 ()"

.SS "const \fBCreatePackets::_101\fP* kipr::create::Create::sensorPacket101 ()"

.SS "const \fBCreatePackets::_2\fP* kipr::create::Create::sensorPacket2 ()"

.SS "const \fBCreatePackets::_3\fP* kipr::create::Create::sensorPacket3 ()"

.SS "const \fBCreatePackets::_4\fP* kipr::create::Create::sensorPacket4 ()"

.SS "const \fBCreatePackets::_5\fP* kipr::create::Create::sensorPacket5 ()"

.SS "void kipr::create::Create::setAngle (const int angle)"

.SS "bool kipr::create::Create::setBaudRate (const unsigned char & baudCode)"

.SS "void kipr::create::Create::setDefaultBaudRate (const \fBBaudRate\fP defaultBaudRate)\fC [inline]\fP"

.SS "void kipr::create::Create::setDistance (const int distance)"

.SS "void kipr::create::Create::setFullMode ()"

.SS "void kipr::create::Create::setLeds (const bool & advance, const bool & play, const unsigned char & color, const unsigned char & brightness)"

.SS "void kipr::create::Create::setMode (const \fBCreate::Mode\fP & mode)"

.SS "void kipr::create::Create::setOffMode ()"

.SS "void kipr::create::Create::setPassiveMode ()"

.SS "void kipr::create::Create::setRefreshRate (const unsigned short & refreshRate)"

.SS "void kipr::create::Create::setSafeMode ()"

.SS "\fBsensor::Sensor\fP<unsigned char>* kipr::create::Create::songNumber () const"

.SS "\fBsensor::Sensor\fP<unsigned char>* kipr::create::Create::songPlaying () const"

.SS "void kipr::create::Create::spin (const short & speed)"
Spin the create at a constant velocity\&. 
.PP
\fBParameters\fP
.RS 4
\fIspeed\fP The speed each motor should move at\&. Positive is counter-clockwise\&. 
.RE
.PP

.SS "void kipr::create::Create::spinClockwise (const short & speed)"

.SS "void kipr::create::Create::spinCounterClockwise (const short & speed)"

.SS "const \fBCreateState\fP* kipr::create::Create::state ()"

.SS "void kipr::create::Create::stop ()"

.SS "void kipr::create::Create::turn (const short & angle, const unsigned short & speed)"
A very accurate turn method based on time rather than the create's own readings, which are often less than accurate\&. 
.PP
\fBParameters\fP
.RS 4
\fIangle\fP The angle to turn, in degrees\&. Positive is counter-clockwise\&. 
.br
\fIspeed\fP The speed each wheel should move at, in mm/s\&. The angular velocity will be double this value\&. 
.RE
.PP
\fB\fBThis\fP function is blocking\&.\fP
.RS 4

.RE
.PP

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::virtualWall () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::wall () const"

.SS "\fBsensor::Sensor\fP<unsigned short>* kipr::create::Create::wallSignal () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::wheelDropCaster () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::wheelDropLeft () const"

.SS "\fBsensor::Sensor\fP<bool>* kipr::create::Create::wheelDropRight () const"

.SS "bool kipr::create::Create::write (const unsigned char & c)"

.SS "bool kipr::create::Create::write (const unsigned char * data, const size_t & len)"


.SH "Author"
.PP 
Generated automatically by Doxygen for libkipr from the source code\&.
